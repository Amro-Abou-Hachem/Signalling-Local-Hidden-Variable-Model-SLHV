using JuMP, MosekTools

""" 
We provide below an implementation of the LPs provided in the text. 
In this script we used Mosek Solver. If Mosek is not available to the user, it is possible to change the solver to Clarabel which 
is an open source solver. This is done by changing  model = Model(Mosek.Optimizer) to
model = Model(Clarabel.Optimizer) in the needed functions. 
"""
function lambda_to_matrix(λ, m, n, k)
    """
    This function returns the determinstic outcome for the
        hidden variable λ, for all possible choices of measurement 
        for Alice and Bob. 
    m: number of x settings
    n: number of y settings
    k: number of outputs (For the party of intereset)
    λ: the determinstic strategy number
    The is function works by converting λ into a decomosition of base k. 
    """
    total = m * n
    digits = zeros(Int, total)
    temp = λ
    for i in 1:total
        digits[i] = temp % k + 1
        temp ÷= k
    end
    return reshape(digits, (m, n))
end


function generate_strategies(na, nb, nx, ny)
    """
    The total number of determinstic strategies is generated 
    by generating all possible combinations of Alice's and Bob's 
    determinstic strategies generated by the lambda_to_matrix
    function.  
    na: Number of Alice's outcomes
    nb: Number of Bob's outcomes
    nx: Number of Alice's settings
    ny: Number of Bob's settings
    """
    nstrata = na^(nx + ny)
    nstratb = nb^(ny + nx)
    nstrat = nstrata * nstratb
    strategies = []
    for i in 1:nstrata, j in 1:nstratb
        a = lambda_to_matrix(i, nx, ny, na)
        b = lambda_to_matrix(j, nx, ny, nb)
        push!(strategies, (a, b))
    end
    return strategies
end




function calculate_visibility(p, α, β, strategies=nothing)
    """
    This function takes as an input the probability distribution and the allowed
        signaling weights α,β and returns the visibility in this SLHV.
    p: Probability distribution for which the visibility is to be calculated, it must have the shape array(na,nb,nx,ny)
    α: The signaling weights allowed on Alice's side, it must have the shape array(na,nx,ny,ny)
    β: The signaling weights allowed on Bob's side, it must have the shape array(nb,ny,nx,nx)
    strategies: Supplying determinstic strategies is optional, otherwise they are generated by the generate_strategies function.
    The function is an implementation of LP provided in text.
    """
    na, nb, nx, ny = size(p)
    if strategies === nothing
        strategies = generate_strategies(na, nb, nx, ny)
    end
    nstrata, nstratb = na^(nx + ny), nb^(ny + nx)
    nstrat = nstrata * nstratb
    model = Model(Mosek.Optimizer)
    set_silent(model)
    @variable(model, 0 <= v <= 1)
    @variable(model, q[1:nstrat] >= 0)
    @constraint(model, sum(q[λ] for λ ∈ 1:nstrat) == 1)
    @constraint(model, v_equations[a=1:na, b=1:nb, x=1:nx, y=1:ny],
        v * p[a, b, x, y] + (1 - v) / (na * nb) == sum(
            q[λ] * (strategies[λ][1][x, y] == a ? 1 : 0) * (strategies[λ][2][x, y] == b ? 1 : 0)
            for λ in 1:nstrat
        ),
    )
    @constraint(model, signaling_alice[a=1:na, x=1:nx, y=1:ny, y′=1:ny],
        sum(q[λ] * abs((strategies[λ][1][x, y] == a ? 1 : 0) - (strategies[λ][1][x, y′] == a ? 1 : 0)) for λ ∈ 1:nstrat) <= α[a, x, y, y′])
    @constraint(model, signaling_bob[b=1:nb, y=1:ny, x=1:nx, x′=1:nx],
        sum(q[λ] * abs((strategies[λ][2][x, y] == b ? 1 : 0) - (strategies[λ][2][x′, y] == b ? 1 : 0)) for λ ∈ 1:nstrat) <= β[b, y, x, x′])
    @objective(model, Max, v)
    optimize!(model)
    return value(v)
end

function calculate_visibility_dual(p, α, β, strategies=nothing)
    """
    This function takes as an input the probability distribution and the allowed
        signaling weights α,β and returns the visibility in this SLHV, and the coefficients 
        c_{abxy},e_{axyy'} and d_{byxx'} and μ that define the corresponding inequality for p.
    p: Probability distribution for which the visibility is to be calculated, it must have the shape array(na,nb,nx,ny)
    α: The signaling weights allowed on Alice's side, it must have the shape array(na,nx,ny,ny)
    β: The signaling weights allowed on Bob's side, it must have the shape array(nb,ny,nx,nx)
    strategies: Supplying determinstic strategies is optional, otherwise they are generated by the generate_strategies function
    The function is an implementation of dual LP provided in text.
    """
    na, nb, nx, ny = size(p)
    if strategies === nothing
        strategies = generate_strategies(na, nb, nx, ny)
    end
    nstrata, nstratb = na^(nx + ny), nb^(ny + nx)
    nstrat = nstrata * nstratb
    model = Model(Mosek.Optimizer)
    set_silent(model)
    @variable(model, c[1:na, 1:nb, 1:nx, 1:ny])
    @variable(model, e[1:na, 1:nx, 1:ny, 1:ny] >= 0)
    @variable(model, d[1:nb, 1:ny, 1:nx, 1:nx] >= 0)
    @variable(model, μ)
    @constraint(model, normalization, sum(c[a, b, x, y] * (p[a, b, x, y] - 1 / (na * nb)) for a ∈ 1:na, b ∈ 1:nb, x ∈ 1:nx, y ∈ 1:ny) + 1 == 0)
    @constraint(
        model, inequality_constraint[λ=1:nstrat],
        sum(c[a, b, x, y] * (strategies[λ][1][x, y] == a ? 1 : 0) * (strategies[λ][2][x, y] == b ? 1 : 0) for a ∈ 1:na, b ∈ 1:nb, x ∈ 1:nx, y ∈ 1:ny) +
        sum(e[a, x, y, yp] * abs((strategies[λ][1][x, y] == a ? 1 : 0) - (strategies[λ][1][x, yp] == a ? 1 : 0)) for a ∈ 1:na, x ∈ 1:nx, y ∈ 1:ny, yp ∈ 1:ny) +
        sum(d[b, y, x, xp] * abs((strategies[λ][2][x, y] == b ? 1 : 0) - (strategies[λ][2][xp, y] == b ? 1 : 0)) for b ∈ 1:nb, y ∈ 1:ny, x ∈ 1:nx, xp ∈ 1:nx)
        >=
        μ
    )
    expr = 1 - μ + sum(c[a, b, x, y] * p[a, b, x, y] for a ∈ 1:na, b ∈ 1:nb, x ∈ 1:nx, y ∈ 1:ny) +
           sum(e[a, x, y, ys] * α[a, x, y, ys] for a ∈ 1:na, x ∈ 1:nx, y ∈ 1:ny, ys ∈ 1:ny) +
           sum(d[b, y, x, xs] * β[b, y, x, xs] for b ∈ 1:nb, y ∈ 1:ny, x ∈ 1:nx, xs ∈ 1:nx)
    @objective(model, Min, expr)
    optimize!(model)
    return value(expr), value(c), value(d), value(e), value(μ)

end